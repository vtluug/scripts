#!/bin/bash
#set -x
#jkh exit
# chkconfig: 2345 98 90
# description: This thing is NAT, map IPs, and CheckNet mixed into one, with
#              a wireless interface added just for fun.


# J.K. Harris -- 7 April 2004
# J.K. Harris -- 23 January 2009 -- Clean up.

# Assumes:
#
# eth0 - outside interface -- this interface should be up and running!
# eth1 - inside interface
#

### THINGS THAT NEED TO BE DONE
# ifconfig's output is non-compliant on ubuntu; on other linuxes and obsd, it does not say "inet addr:"
# must transition to using iproute2 or `ifconfig $IFACE inet` and parsing


### The following is a list of IP address that should be mapped through
### to the outside.

#jkh -- temporarly taking luug3 out so we can track down who is using the IP address.
Not_Inside_Hosts='
'

Inside_Hosts='
        luug.ece.vt.edu
	luug0.ece.vt.edu
	luug1.ece.vt.edu
	luug2.ece.vt.edu
	luug3.ece.vt.edu
        mjh.ece.vt.edu
'


# Make sure the path is proper.

export PATH=/sbin:/usr/sbin:${PATH}

# Log modprobe messages to stderr or syslog.
quiet="-s"


##
## Utility routine: get_IP_address
##

known_DNS=198.82.247.98
                                                                                
get_IP_address ()
{
	line=`host -t A ${1} ${known_DNS} | tail -n 1`
	if [[ ${line} == *not* ]] ; then
		echo "${1} not found."
		return 1
	elif [[ ${line} == *has\ address* ]] ; then
		line=`echo ${line} | cut -d' ' -f 4`
	elif [[ ${line} == *domain\ name\ pointer* ]] ; then
		#line=`echo ${line} | cut -d' ' -f 5`
		line=${1}
	else
		echo "Something went wrong!"
		exit 2
	fi

	echo $line
	return 0
}



##
## Some initializations:
##



# Convert Inside_Hosts to inside_hosts

inside_hosts=""
for i in ${Inside_Hosts} ; do
	inside_hosts="${inside_hosts}	"`get_IP_address ${i}`
done

# Find the IP address of the outside interface.
outside_interface_IP_address=`ifconfig eth0 | awk '/inet addr:/ { print $2 }' | cut -d':' -f2`



##
## Load/UnLoad some modules.
##


do_modules ()	# if $1 = '-r' unload (remove)
{
    for module in /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/* ; do
	module=`basename ${module} .ko`
	modprobe ${quiet} $1 ${module}
    done
}



# Flush the arp tables.

flush_arp_tables ()
{
    for IP in `arp -n | awk '{ if ($5 == "eth0") print $1; }'` ; do
	arp --delete ${IP} --device eth0
    done
    for IP in `arp -n | awk '{ if ($5 == "eth1") print $1; }'` ; do
	arp --delete ${IP} --device eth1
    done
}



# Delete static routes, i.e. anything with 255.255.255.255 as the netmask.
# Also, delete any arp entries for that machine.

delete_static_routes ()
{
    for IP in `route -n | awk '/255.255.255.255/ { print $1 }'` ; do
	route del -host ${IP} eth1
    done
}


delete_mapped_through_IP_addresses ()
{
    delete_static_routes
    flush_arp_tables
    # There is a bug in the arp table display, it does not show the last
    # entry everytime.
    flush_arp_tables
}



# Attempt to do a "Unsolicited ARP" to the Burris router.
arp_ping_the_router ()
{
    echo 1 > /proc/sys/net/ipv4/ip_nonlocal_bind
    arping -q -I eth0 -U -c 2 -s $1 128.173.91.254
    echo 0 > /proc/sys/net/ipv4/ip_nonlocal_bind
}

 
add_host ()
{
    if [ "$2" = "inside" ] ; then
        echo -en "$1 -- $2    \n"       # Give user some feed back
	route add -host $1 dev eth1     # add static route
	arp -i eth0 -Ds $1 eth0 pub     # proxy arp to the outside
	
	arp_ping_the_router $1
    else
	arp -i eth1 -Ds $1 eth1 pub     # proxy arp that machine to the inside
    fi
}

 
map_through_IP_addresses ()
{
    for i in 88 89 90 91 ; do
	
	let j=0
	while [ ${j} -le 255 ] ; do
            # Don't do us (outside interface).
            # Don't do first and last address of subnet.
	    case "128.173.${i}.${j}" in
		(128.173.88.0)	 			let j=${j}+1; continue ;;      # start of subnet
		(128.173.91.255)			let j=${j}+1; continue ;;      # end of subnet
		(${outside_interface_IP_address})	let j=${j}+1; continue ;;      # this machine
	    esac
	    
            # Check inside host list.
	    if expr "${inside_hosts}" : ".*\<128\\.173\\.${i}\\.${j}\>.*" > /dev/null 2>&1 ; then
		add_host 128.173.${i}.${j} inside
	    else
		add_host 128.173.${i}.${j} outside
	    fi
	    
	    let j=${j}+1
	done
	
    done
}


start () 
{
    do_modules

    ifconfig eth1 10.0.0.1 netmask 255.0.0.0 up

# Add IPv6 address to internal network
#via ifconfig eth1 add 2001:470:8:951::1/64
    ifconfig eth1 mtu 9000

    iptables --table nat --flush

    # Use this if eth0 is dhcp (changing IP address):
    # iptables --table nat --append POSTROUTING --out-interface eth0 --jump MASQUERADE
    # otherwise use this:
    iptables --table nat --append POSTROUTING --source 10.0.0.0/8 --out-interface eth0 --jump SNAT --to ${outside_interface_IP_address}

    echo '1' > /proc/sys/net/ipv4/ip_forward

    service dnsmasq stop

    map_through_IP_addresses

    service dnsmasq start

   # Block snmp to the outside world.
   # 32 July 2007  jkh  -- Allow monitor machine through.

#   iptables -A INPUT   --protocol udp --source monitor.ece.vt.edu --dport snmp -j ACCEPT
#   iptables -A INPUT   --protocol udp --dport snmp -j DROP
#   iptables -A FORWARD --protocol udp --source monitor.ece.vt.edu --dport snmp -j ACCEPT
#   iptables -A FORWARD --protocol udp --dport snmp -j DROP

   # Block telnet from the outside world.

#   iptables -A FORWARD --protocol tcp --dport telnet -j DROP
}


stop () 
{
    service dnsmasq stop
    
    delete_mapped_through_IP_addresses

    echo '0' > /proc/sys/net/ipv4/ip_forward

#XX    iptables -t nat -F

    ifconfig eth1 down

    # removing the modules never works, just leave them...
    do_modules '-r'
    do_modules '-r'
}


##
## Main routine.  Stop/Start/ReStart
##

case $1 in
	start)
		start
	;;
	stop)
		stop
	;;
	restart)
		stop
		start
	;;
	remap)
		delete_mapped_through_IP_addresses
		map_through_IP_addresses
	;;
	*)
		echo "Usage: $0 {start|stop|restart|remap}"
		exit 1
esac
